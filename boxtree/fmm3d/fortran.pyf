!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module fortran ! in 
    interface  ! in :fortran
        subroutine lfmm3d(nd,eps,nsource,source,ifcharge,charge,ifdipole,dipvec,iper,ifpgh,pot,grad,hess,ntarg,targ,ifpghtarg,pottarg,gradtarg,hesstarg,ier) ! in :fortran:FMM3D/src/Laplace/lfmm3d.f
            integer, optional,check(shape(charge,0)==nd),depend(charge) :: nd=shape(charge,0)
            double precision :: eps
            integer :: nsource
            double precision dimension(3,*) :: source
            integer :: ifcharge
            double precision dimension(nd,*) :: charge
            integer :: ifdipole
            double precision dimension(nd,3,*),depend(nd) :: dipvec
            integer :: iper
            integer :: ifpgh
            double precision dimension(nd,*),depend(nd) :: pot
            double precision dimension(nd,3,*),depend(nd) :: grad
            double precision dimension(nd,6,*),depend(nd) :: hess
            integer :: ntarg
            double precision dimension(3,*) :: targ
            integer :: ifpghtarg
            double precision dimension(nd,*),depend(nd) :: pottarg
            double precision dimension(nd,3,*),depend(nd) :: gradtarg
            double precision dimension(nd,6,*),depend(nd) :: hesstarg
            integer :: ier
        end subroutine lfmm3d
        subroutine lfmm3dmain(nd,eps,nsource,sourcesort,ifcharge,chargesort,ifdipole,dipvecsort,ntarg,targsort,nexpc,expcsort,iaddr,rmlexp,lmptot,mptemp,mptemp2,lmptemp,itree,ltree,ipointer,ndiv,nlevels,nboxes,iper,boxsize,centers,isrcse,itargse,iexpcse,rscales,laddr,nterms,ifpgh,pot,grad,hess,ifpghtarg,pottarg,gradtarg,hesstarg,ntj,tsort,scjsort,ifnear,ier) ! in :fortran:FMM3D/src/Laplace/lfmm3d.f
            integer, optional,check(shape(chargesort,0)==nd),depend(chargesort) :: nd=shape(chargesort,0)
            double precision :: eps
            integer, optional,check(shape(sourcesort,1)==nsource),depend(sourcesort) :: nsource=shape(sourcesort,1)
            double precision dimension(3,nsource) :: sourcesort
            integer :: ifcharge
            double precision dimension(nd,*) :: chargesort
            integer :: ifdipole
            double precision dimension(nd,3,*),depend(nd) :: dipvecsort
            integer, optional,check(shape(targsort,1)==ntarg),depend(targsort) :: ntarg=shape(targsort,1)
            double precision dimension(3,ntarg) :: targsort
            integer, optional,check(shape(expcsort,1)==nexpc),depend(expcsort) :: nexpc=shape(expcsort,1)
            double precision dimension(3,nexpc) :: expcsort
            integer*8 dimension(2,nboxes) :: iaddr
            double precision dimension(lmptot) :: rmlexp
            integer*8, optional,check(len(rmlexp)>=lmptot),depend(rmlexp) :: lmptot=len(rmlexp)
            double precision dimension(lmptemp) :: mptemp
            double precision dimension(lmptemp),depend(lmptemp) :: mptemp2
            integer, optional,check(len(mptemp)>=lmptemp),depend(mptemp) :: lmptemp=len(mptemp)
            integer dimension(ltree) :: itree
            integer*8, optional,check(len(itree)>=ltree),depend(itree) :: ltree=len(itree)
            integer*8 dimension(8) :: ipointer
            integer :: ndiv
            integer, optional,check((len(boxsize)-1)>=nlevels),depend(boxsize) :: nlevels=(len(boxsize)-1)
            integer, optional,check(shape(iaddr,1)==nboxes),depend(iaddr) :: nboxes=shape(iaddr,1)
            integer :: iper
            double precision dimension(nlevels + 1) :: boxsize
            double precision dimension(3,nboxes),depend(nboxes) :: centers
            integer dimension(2,nboxes),depend(nboxes) :: isrcse
            integer dimension(2,nboxes),depend(nboxes) :: itargse
            integer dimension(2,nboxes),depend(nboxes) :: iexpcse
            double precision dimension(nlevels + 1),depend(nlevels) :: rscales
            integer dimension(2,nlevels + 1),depend(nlevels) :: laddr
            integer dimension(nlevels + 1),depend(nlevels) :: nterms
            integer :: ifpgh
            double precision dimension(nd,*),depend(nd) :: pot
            double precision dimension(nd,3,*),depend(nd) :: grad
            double precision dimension(nd,6,*),depend(nd) :: hess
            integer :: ifpghtarg
            double precision dimension(nd,*),depend(nd) :: pottarg
            double precision dimension(nd,3,*),depend(nd) :: gradtarg
            double precision dimension(nd,6,*),depend(nd) :: hesstarg
            integer, optional,check((shape(tsort,1)-1)==ntj),depend(tsort) :: ntj=(shape(tsort,1)-1)
            double complex dimension(nd,ntj + 1,2 * ntj + 1,nexpc),depend(nd,nexpc) :: tsort
            double precision dimension(nexpc),depend(nexpc) :: scjsort
            integer :: ifnear
            integer :: ier
        end subroutine lfmm3dmain
        subroutine lfmm3dexpc_direct(nd,istart,iend,jstart,jend,source,ifcharge,charge,ifdipole,dipvec,expc,texps,scj,ntj,wlege,nlege) ! in :fortran:FMM3D/src/Laplace/lfmm3d.f
            integer, optional,check(shape(charge,0)==nd),depend(charge) :: nd=shape(charge,0)
            integer :: istart
            integer :: iend
            integer :: jstart
            integer :: jend
            double precision dimension(3,*) :: source
            integer :: ifcharge
            double precision dimension(nd,*) :: charge
            integer :: ifdipole
            double precision dimension(nd,3,*),depend(nd) :: dipvec
            double precision dimension(3,*) :: expc
            double complex dimension(nd,ntj + 1,2 * ntj + 1,*),depend(nd) :: texps
            double precision dimension(*) :: scj
            integer, optional,check((shape(texps,1)-1)==ntj),depend(texps) :: ntj=(shape(texps,1)-1)
            double precision dimension(*) :: wlege
            integer :: nlege
        end subroutine lfmm3dexpc_direct
        subroutine hfmm3d(nd,eps,zk,nsource,source,ifcharge,charge,ifdipole,dipvec,iper,ifpgh,pot,grad,hess,ntarg,targ,ifpghtarg,pottarg,gradtarg,hesstarg,ier) ! in :fortran:FMM3D/src/Helmholtz/hfmm3d.f
            integer, optional,check(shape(charge,0)==nd),depend(charge) :: nd=shape(charge,0)
            double precision :: eps
            double complex :: zk
            integer, optional,check(shape(source,1)==nsource),depend(source) :: nsource=shape(source,1)
            double precision dimension(3,nsource) :: source
            integer :: ifcharge
            double complex dimension(nd,*) :: charge
            integer :: ifdipole
            double complex dimension(nd,3,*),depend(nd) :: dipvec
            integer :: iper
            integer :: ifpgh
            double complex dimension(nd,*),depend(nd) :: pot
            double complex dimension(nd,3,*),depend(nd) :: grad
            double complex dimension(nd,6,*),depend(nd) :: hess
            integer, optional,check(shape(targ,1)==ntarg),depend(targ) :: ntarg=shape(targ,1)
            double precision dimension(3,ntarg) :: targ
            integer :: ifpghtarg
            double complex dimension(nd,3,*),depend(nd) :: pottarg
            double complex dimension(nd,3,*),depend(nd) :: gradtarg
            double complex dimension(nd,6,*),depend(nd) :: hesstarg
            integer :: ier
        end subroutine hfmm3d
        subroutine hfmm3dmain(nd,eps,zk,nsource,sourcesort,ifcharge,chargesort,ifdipole,dipvecsort,ntarg,targsort,nexpc,expcsort,radssort,iaddr,rmlexp,lmptot,mptemp,mptemp2,lmptemp,itree,ltree,ipointer,ndiv,nlevels,nboxes,iper,boxsize,centers,isrcse,itargse,iexpcse,rscales,laddr,nterms,ifpgh,pot,grad,hess,ifpghtarg,pottarg,gradtarg,hesstarg,ntj,jsort,scjsort,ifnear,ier) ! in :fortran:FMM3D/src/Helmholtz/hfmm3d.f
            integer, optional,check(shape(chargesort,0)==nd),depend(chargesort) :: nd=shape(chargesort,0)
            double precision :: eps
            double complex :: zk
            integer, optional,check(shape(sourcesort,1)==nsource),depend(sourcesort) :: nsource=shape(sourcesort,1)
            double precision dimension(3,nsource) :: sourcesort
            integer :: ifcharge
            double complex dimension(nd,*) :: chargesort
            integer :: ifdipole
            double complex dimension(nd,3,*),depend(nd) :: dipvecsort
            integer, optional,check(shape(targsort,1)==ntarg),depend(targsort) :: ntarg=shape(targsort,1)
            double precision dimension(3,ntarg) :: targsort
            integer, optional,check(shape(expcsort,1)==nexpc),depend(expcsort) :: nexpc=shape(expcsort,1)
            double precision dimension(3,nexpc) :: expcsort
            double precision dimension(nexpc),depend(nexpc) :: radssort
            integer*8 dimension(2,nboxes) :: iaddr
            double precision dimension(lmptot) :: rmlexp
            integer*8, optional,check(len(rmlexp)>=lmptot),depend(rmlexp) :: lmptot=len(rmlexp)
            double precision dimension(lmptemp) :: mptemp
            double precision dimension(lmptemp),depend(lmptemp) :: mptemp2
            integer, optional,check(len(mptemp)>=lmptemp),depend(mptemp) :: lmptemp=len(mptemp)
            integer dimension(ltree) :: itree
            integer*8, optional,check(len(itree)>=ltree),depend(itree) :: ltree=len(itree)
            integer*8 dimension(8) :: ipointer
            integer :: ndiv
            integer, optional,check((len(boxsize)-1)>=nlevels),depend(boxsize) :: nlevels=(len(boxsize)-1)
            integer, optional,check(shape(iaddr,1)==nboxes),depend(iaddr) :: nboxes=shape(iaddr,1)
            integer :: iper
            double precision dimension(nlevels + 1) :: boxsize
            double precision dimension(3,nboxes),depend(nboxes) :: centers
            integer dimension(2,nboxes),depend(nboxes) :: isrcse
            integer dimension(2,nboxes),depend(nboxes) :: itargse
            integer dimension(2,nboxes),depend(nboxes) :: iexpcse
            double precision dimension(nlevels + 1),depend(nlevels) :: rscales
            integer dimension(2,nlevels + 1),depend(nlevels) :: laddr
            integer dimension(nlevels + 1),depend(nlevels) :: nterms
            integer :: ifpgh
            double complex dimension(nd,*),depend(nd) :: pot
            double complex dimension(nd,3,*),depend(nd) :: grad
            double complex dimension(nd,6,*),depend(nd) :: hess
            integer :: ifpghtarg
            double complex dimension(nd,*),depend(nd) :: pottarg
            double complex dimension(nd,3,*),depend(nd) :: gradtarg
            double complex dimension(nd,6,*),depend(nd) :: hesstarg
            integer, optional,check((shape(jsort,1)-1)==ntj),depend(jsort) :: ntj=(shape(jsort,1)-1)
            double complex dimension(nd,ntj + 1,2 * ntj + 1,nexpc),depend(nd,nexpc) :: jsort
            double precision dimension(nexpc),depend(nexpc) :: scjsort
            integer :: ifnear
            integer :: ier
        end subroutine hfmm3dmain
        subroutine hfmm3dexpc_direct(nd,zk,istart,iend,jstart,jend,source,ifcharge,charge,ifdipole,dipvec,targ,texps,scj,ntj,wlege,nlege) ! in :fortran:FMM3D/src/Helmholtz/hfmm3d.f
            integer, optional,check(shape(charge,0)==nd),depend(charge) :: nd=shape(charge,0)
            double complex :: zk
            integer :: istart
            integer :: iend
            integer :: jstart
            integer :: jend
            double precision dimension(3,*) :: source
            integer :: ifcharge
            double complex dimension(nd,*) :: charge
            integer :: ifdipole
            double complex dimension(nd,3,*),depend(nd) :: dipvec
            double precision dimension(3,*) :: targ
            double complex dimension(nd,ntj + 1,2 * ntj + 1,*),depend(nd) :: texps
            double precision dimension(*) :: scj
            integer, optional,check((shape(texps,1)-1)==ntj),depend(texps) :: ntj=(shape(texps,1)-1)
            double precision dimension(nlege + 1,nlege + 1) :: wlege
            integer, optional,check((shape(wlege,0)-1)==nlege),depend(wlege) :: nlege=(shape(wlege,0)-1)
        end subroutine hfmm3dexpc_direct
        subroutine pts_tree_mem(src,ns,targ,nt,idivflag,ndiv,nlmin,nlmax,ifunif,iper,nlevels,nboxes,ltree) ! in :fortran:FMM3D/src/Common/pts_tree3d.f
            double precision dimension(3,ns) :: src
            integer, optional,check(shape(src,1)==ns),depend(src) :: ns=shape(src,1)
            double precision dimension(3,nt) :: targ
            integer, optional,check(shape(targ,1)==nt),depend(targ) :: nt=shape(targ,1)
            integer :: idivflag
            integer :: ndiv
            integer :: nlmin
            integer :: nlmax
            integer :: ifunif
            integer :: iper
            integer :: nlevels
            integer :: nboxes
            integer*8 :: ltree
        end subroutine pts_tree_mem
        subroutine pts_tree_build(src,ns,targ,nt,idivflag,ndiv,nlmin,nlmax,ifunif,iper,nlevels,nboxes,ltree,itree,iptr,centers,boxsize) ! in :fortran:FMM3D/src/Common/pts_tree3d.f
            double precision dimension(3,ns) :: src
            integer, optional,check(shape(src,1)==ns),depend(src) :: ns=shape(src,1)
            double precision dimension(3,nt) :: targ
            integer, optional,check(shape(targ,1)==nt),depend(targ) :: nt=shape(targ,1)
            integer :: idivflag
            integer :: ndiv
            integer :: nlmin
            integer :: nlmax
            integer :: ifunif
            integer :: iper
            integer, optional,check((len(boxsize)-1)>=nlevels),depend(boxsize) :: nlevels=(len(boxsize)-1)
            integer, optional,check(shape(centers,1)==nboxes),depend(centers) :: nboxes=shape(centers,1)
            integer*8, optional,check(len(itree)>=ltree),depend(itree) :: ltree=len(itree)
            integer dimension(ltree) :: itree
            integer*8 dimension(8) :: iptr
            double precision dimension(3,nboxes) :: centers
            double precision dimension(nlevels + 1) :: boxsize
        end subroutine pts_tree_build
        subroutine sort_pts_to_children(ibox,nboxes,centers,ichild,src,ns,isrc,isrcse) ! in :fortran:FMM3D/src/Common/pts_tree3d.f
            integer :: ibox
            integer, optional,check(shape(centers,1)==nboxes),depend(centers) :: nboxes=shape(centers,1)
            double precision dimension(3,nboxes) :: centers
            integer dimension(8,nboxes),depend(nboxes) :: ichild
            double precision dimension(3,ns) :: src
            integer, optional,check(shape(src,1)==ns),depend(src) :: ns=shape(src,1)
            integer dimension(ns),depend(ns) :: isrc
            integer dimension(2,nboxes),depend(nboxes) :: isrcse
        end subroutine sort_pts_to_children
        subroutine pts_tree_fix_lr(centers,nlevels,nboxes,boxsize,nbmax,nlmax,iper,laddr,ilevel,iparent,nchild,ichild,nnbors,nbors) ! in :fortran:FMM3D/src/Common/pts_tree3d.f
            double precision dimension(3,nbmax) :: centers
            integer :: nlevels
            integer :: nboxes
            double precision dimension(nlmax + 1) :: boxsize
            integer, optional,check(shape(centers,1)==nbmax),depend(centers) :: nbmax=shape(centers,1)
            integer, optional,check((len(boxsize)-1)>=nlmax),depend(boxsize) :: nlmax=(len(boxsize)-1)
            integer :: iper
            integer dimension(2,nlmax + 1),depend(nlmax) :: laddr
            integer dimension(nbmax),depend(nbmax) :: ilevel
            integer dimension(nbmax),depend(nbmax) :: iparent
            integer dimension(nbmax),depend(nbmax) :: nchild
            integer dimension(8,nbmax),depend(nbmax) :: ichild
            integer dimension(nbmax),depend(nbmax) :: nnbors
            integer dimension(27,nbmax),depend(nbmax) :: nbors
        end subroutine pts_tree_fix_lr
        subroutine pts_tree_reorg(nboxes,centers,nlevels,laddr,laddrtail,ilevel,iparent,nchild,ichild,iflag) ! in :fortran:FMM3D/src/Common/pts_tree3d.f
            integer, optional,check(shape(centers,1)==nboxes),depend(centers) :: nboxes=shape(centers,1)
            double precision dimension(3,nboxes) :: centers
            integer, optional,check((shape(laddr,1)-1)==nlevels),depend(laddr) :: nlevels=(shape(laddr,1)-1)
            integer dimension(2,nlevels + 1) :: laddr
            integer dimension(2,nlevels + 1),depend(nlevels) :: laddrtail
            integer dimension(nboxes),depend(nboxes) :: ilevel
            integer dimension(nboxes),depend(nboxes) :: iparent
            integer dimension(nboxes),depend(nboxes) :: nchild
            integer dimension(8,nboxes),depend(nboxes) :: ichild
            integer dimension(nboxes),depend(nboxes) :: iflag
        end subroutine pts_tree_reorg
        subroutine pts_tree_sort(n,xys,itree,ltree,nboxes,nlevels,iptr,centers,ixy,ixyse) ! in :fortran:FMM3D/src/Common/pts_tree3d.f
            integer, optional,check(shape(xys,1)==n),depend(xys) :: n=shape(xys,1)
            double precision dimension(3,n) :: xys
            integer dimension(ltree) :: itree
            integer*8, optional,check(len(itree)>=ltree),depend(itree) :: ltree=len(itree)
            integer, optional,check(shape(centers,1)==nboxes),depend(centers) :: nboxes=shape(centers,1)
            integer :: nlevels
            integer*8 dimension(8) :: iptr
            double precision dimension(3,nboxes) :: centers
            integer dimension(n),depend(n) :: ixy
            integer dimension(2,nboxes),depend(nboxes) :: ixyse
        end subroutine pts_tree_sort
    end interface 
end python module fortran

! This file was auto-generated with f2py (version:1.21.4).
! See http://cens.ioc.ee/projects/f2py2e/
